name: Build All Emulators ARM64

on:
  schedule:
    - cron: '0 4 * * 0'
  workflow_dispatch:
  push:
    paths:
      - '.github/workflows/build-emulators.yml'

permissions:
  contents: write
  actions: write

env:
  CACHE_KEY: emu-deps-base
  BUILD_TIMEOUT: 19800  # 5h30 in seconds (leave 30min for cache save)

jobs:
  # ===========================================================================
  # PREPARE: Create and cache base image with all dependencies
  # ===========================================================================
  prepare:
    runs-on: ubuntu-24.04
    outputs:
      azahar_version: ${{ steps.versions.outputs.azahar_version }}
      dolphin_commit: ${{ steps.versions.outputs.dolphin_commit }}
      dolphin_short: ${{ steps.versions.outputs.dolphin_short }}
      duck_commit: ${{ steps.versions.outputs.duck_commit }}
      duck_short: ${{ steps.versions.outputs.duck_short }}
      esde_version: ${{ steps.versions.outputs.esde_version }}
      melonds_version: ${{ steps.versions.outputs.melonds_version }}
      ppsspp_version: ${{ steps.versions.outputs.ppsspp_version }}
      xemu_version: ${{ steps.versions.outputs.xemu_version }}
      build_azahar: ${{ steps.decide.outputs.build_azahar }}
      build_dolphin: ${{ steps.decide.outputs.build_dolphin }}
      build_duckstation: ${{ steps.decide.outputs.build_duckstation }}
      build_esde: ${{ steps.decide.outputs.build_esde }}
      build_melonds: ${{ steps.decide.outputs.build_melonds }}
      build_ppsspp: ${{ steps.decide.outputs.build_ppsspp }}
      build_xemu: ${{ steps.decide.outputs.build_xemu }}
      build_libretro: ${{ steps.decide.outputs.build_libretro }}
      build_setperf: ${{ steps.decide.outputs.build_setperf }}
      hash_azahar: ${{ steps.hashes.outputs.hash_azahar }}
      hash_dolphin: ${{ steps.hashes.outputs.hash_dolphin }}
      hash_duck_deps: ${{ steps.hashes.outputs.hash_duck_deps }}
      hash_duck: ${{ steps.hashes.outputs.hash_duck }}
      hash_esde: ${{ steps.hashes.outputs.hash_esde }}
      hash_melonds: ${{ steps.hashes.outputs.hash_melonds }}
      hash_ppsspp: ${{ steps.hashes.outputs.hash_ppsspp }}
      hash_xemu: ${{ steps.hashes.outputs.hash_xemu }}
      hash_libretro_heavy: ${{ steps.hashes.outputs.hash_libretro_heavy }}
      hash_libretro_light: ${{ steps.hashes.outputs.hash_libretro_light }}
      hash_setperf: ${{ steps.hashes.outputs.hash_setperf }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Compute job hashes
        id: hashes
        run: |
          WORKFLOW=".github/workflows/build-emulators.yml"

          # Extract hash of each job section from the workflow YAML
          job_hash() {
            local job_name="$1"
            sed -n "/^  ${job_name}:/,/^  [a-z]/p" "$WORKFLOW" | head -n -1 | sha256sum | cut -d' ' -f1
          }

          echo "hash_azahar=$(job_hash 'build-azahar')" >> $GITHUB_OUTPUT
          echo "hash_dolphin=$(job_hash 'build-dolphin')" >> $GITHUB_OUTPUT
          echo "hash_duck_deps=$(job_hash 'build-duckstation-deps')" >> $GITHUB_OUTPUT
          echo "hash_duck=$(job_hash 'build-duckstation')" >> $GITHUB_OUTPUT
          echo "hash_esde=$(job_hash 'build-esde')" >> $GITHUB_OUTPUT
          echo "hash_melonds=$(job_hash 'build-melonds')" >> $GITHUB_OUTPUT
          echo "hash_ppsspp=$(job_hash 'build-ppsspp')" >> $GITHUB_OUTPUT
          echo "hash_xemu=$(job_hash 'build-xemu')" >> $GITHUB_OUTPUT
          echo "hash_libretro_heavy=$(job_hash 'build-libretro-heavy')" >> $GITHUB_OUTPUT
          echo "hash_libretro_light=$(job_hash 'build-libretro-light')" >> $GITHUB_OUTPUT
          echo "hash_setperf=$(job_hash 'build-setperf')" >> $GITHUB_OUTPUT

      - name: Check success markers
        id: markers
        run: |
          # We use the GitHub API to check if cache keys exist
          # This avoids needing 11 separate actions/cache/restore steps
          echo "Checking success markers..."

      - name: Check azahar marker
        id: marker-azahar
        uses: actions/cache/restore@v4
        with:
          path: /tmp/marker
          key: success-azahar-${{ steps.hashes.outputs.hash_azahar }}
          lookup-only: true

      - name: Check dolphin marker
        id: marker-dolphin
        uses: actions/cache/restore@v4
        with:
          path: /tmp/marker
          key: success-dolphin-${{ steps.hashes.outputs.hash_dolphin }}
          lookup-only: true

      - name: Check duckstation-deps marker
        id: marker-duck-deps
        uses: actions/cache/restore@v4
        with:
          path: /tmp/marker
          key: success-duck-deps-${{ steps.hashes.outputs.hash_duck_deps }}
          lookup-only: true

      - name: Check duckstation marker
        id: marker-duck
        uses: actions/cache/restore@v4
        with:
          path: /tmp/marker
          key: success-duck-${{ steps.hashes.outputs.hash_duck }}
          lookup-only: true

      - name: Check esde marker
        id: marker-esde
        uses: actions/cache/restore@v4
        with:
          path: /tmp/marker
          key: success-esde-${{ steps.hashes.outputs.hash_esde }}
          lookup-only: true

      - name: Check melonds marker
        id: marker-melonds
        uses: actions/cache/restore@v4
        with:
          path: /tmp/marker
          key: success-melonds-${{ steps.hashes.outputs.hash_melonds }}
          lookup-only: true

      - name: Check ppsspp marker
        id: marker-ppsspp
        uses: actions/cache/restore@v4
        with:
          path: /tmp/marker
          key: success-ppsspp-${{ steps.hashes.outputs.hash_ppsspp }}
          lookup-only: true

      - name: Check xemu marker
        id: marker-xemu
        uses: actions/cache/restore@v4
        with:
          path: /tmp/marker
          key: success-xemu-${{ steps.hashes.outputs.hash_xemu }}
          lookup-only: true

      - name: Check libretro-heavy marker
        id: marker-libretro-heavy
        uses: actions/cache/restore@v4
        with:
          path: /tmp/marker
          key: success-libretro-heavy-${{ steps.hashes.outputs.hash_libretro_heavy }}
          lookup-only: true

      - name: Check libretro-light marker
        id: marker-libretro-light
        uses: actions/cache/restore@v4
        with:
          path: /tmp/marker
          key: success-libretro-light-${{ steps.hashes.outputs.hash_libretro_light }}
          lookup-only: true

      - name: Check setperf marker
        id: marker-setperf
        uses: actions/cache/restore@v4
        with:
          path: /tmp/marker
          key: success-setperf-${{ steps.hashes.outputs.hash_setperf }}
          lookup-only: true

      - name: Fetch latest versions and check for updates
        id: versions
        run: |
          # Fetch current versions from repo
          CURRENT_AZAHAR=$(cat .azahar-version 2>/dev/null || echo "")
          CURRENT_DOLPHIN=$(cat .dolphin-commit 2>/dev/null || echo "")
          CURRENT_DUCK=$(cat .duckstation-commit 2>/dev/null || echo "")
          CURRENT_ESDE=$(cat .esde-version 2>/dev/null || echo "")
          CURRENT_MELON=$(cat .melonds-version 2>/dev/null || echo "")
          CURRENT_PPSSPP=$(cat .ppsspp-version 2>/dev/null || echo "")
          CURRENT_XEMU=$(cat .xemu-version 2>/dev/null || echo "")

          # Fetch latest versions from upstream (with auth to avoid rate limits)
          AUTH_HEADER="Authorization: token ${{ github.token }}"

          AZAHAR_TAG=$(curl -fsSL -H "$AUTH_HEADER" https://api.github.com/repos/azahar-emu/azahar/releases/latest | jq -r '.tag_name // empty')
          DOLPHIN_COMMIT=$(curl -fsSL -H "$AUTH_HEADER" https://api.github.com/repos/dolphin-emu/dolphin/commits/master | jq -r '.sha // empty')
          DUCK_COMMIT=$(curl -fsSL -H "$AUTH_HEADER" https://api.github.com/repos/stenzek/duckstation/commits/master | jq -r '.sha // empty')
          ESDE_TAG=$(curl -fsSL "https://gitlab.com/api/v4/projects/es-de%2Femulationstation-de/releases" | jq -r '.[0].tag_name // empty')
          MELON_TAG=$(curl -fsSL -H "$AUTH_HEADER" https://api.github.com/repos/melonDS-emu/melonDS/releases/latest | jq -r '.tag_name // empty')
          PPSSPP_TAG=$(curl -fsSL -H "$AUTH_HEADER" https://api.github.com/repos/hrydgard/ppsspp/releases/latest | jq -r '.tag_name // empty')
          XEMU_TAG=$(curl -fsSL -H "$AUTH_HEADER" https://api.github.com/repos/xemu-project/xemu/releases/latest | jq -r '.tag_name // empty')

          # Validate versions are not empty
          if [[ -z "$AZAHAR_TAG" || "$AZAHAR_TAG" == "null" ]]; then
            echo "ERROR: Failed to fetch Azahar version"
            exit 1
          fi
          if [[ -z "$MELON_TAG" || "$MELON_TAG" == "null" ]]; then
            echo "ERROR: Failed to fetch melonDS version"
            exit 1
          fi
          if [[ -z "$PPSSPP_TAG" || "$PPSSPP_TAG" == "null" ]]; then
            echo "ERROR: Failed to fetch PPSSPP version"
            exit 1
          fi
          if [[ -z "$XEMU_TAG" || "$XEMU_TAG" == "null" ]]; then
            echo "ERROR: Failed to fetch xemu version"
            exit 1
          fi

          # Output versions
          echo "azahar_version=$AZAHAR_TAG" >> $GITHUB_OUTPUT
          echo "dolphin_commit=$DOLPHIN_COMMIT" >> $GITHUB_OUTPUT
          echo "dolphin_short=${DOLPHIN_COMMIT:0:7}" >> $GITHUB_OUTPUT
          echo "duck_commit=$DUCK_COMMIT" >> $GITHUB_OUTPUT
          echo "duck_short=${DUCK_COMMIT:0:7}" >> $GITHUB_OUTPUT
          echo "esde_version=$ESDE_TAG" >> $GITHUB_OUTPUT
          echo "melonds_version=$MELON_TAG" >> $GITHUB_OUTPUT
          echo "ppsspp_version=$PPSSPP_TAG" >> $GITHUB_OUTPUT
          echo "xemu_version=$XEMU_TAG" >> $GITHUB_OUTPUT

          # Log versions
          echo "=== Upstream versions ==="
          echo "Azahar: $CURRENT_AZAHAR -> $AZAHAR_TAG"
          echo "Dolphin: ${CURRENT_DOLPHIN:0:7} -> ${DOLPHIN_COMMIT:0:7}"
          echo "DuckStation: ${CURRENT_DUCK:0:7} -> ${DUCK_COMMIT:0:7}"
          echo "ES-DE: $CURRENT_ESDE -> $ESDE_TAG"
          echo "melonDS: $CURRENT_MELON -> $MELON_TAG"
          echo "PPSSPP: $CURRENT_PPSSPP -> $PPSSPP_TAG"
          echo "xemu: $CURRENT_XEMU -> $XEMU_TAG"

          # Version change flags (used by decide step)
          echo "ver_azahar=$([[ "$AZAHAR_TAG" != "$CURRENT_AZAHAR" ]] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "ver_dolphin=$([[ "$DOLPHIN_COMMIT" != "$CURRENT_DOLPHIN" ]] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "ver_duck=$([[ "$DUCK_COMMIT" != "$CURRENT_DUCK" ]] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "ver_esde=$([[ "$ESDE_TAG" != "$CURRENT_ESDE" ]] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "ver_melonds=$([[ "$MELON_TAG" != "$CURRENT_MELON" ]] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "ver_ppsspp=$([[ "$PPSSPP_TAG" != "$CURRENT_PPSSPP" ]] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "ver_xemu=$([[ "$XEMU_TAG" != "$CURRENT_XEMU" ]] && echo true || echo false)" >> $GITHUB_OUTPUT

      - name: Decide which jobs to build
        id: decide
        run: |
          # Force rebuild everything on manual dispatch only
          FORCE="${{ github.event_name == 'workflow_dispatch' }}"

          # Build if: force OR version changed OR no success marker (= modified or failed)
          decide() {
            local name="$1"
            local ver_changed="$2"
            local has_marker="$3"

            if [[ "$FORCE" == "true" ]] || [[ "$ver_changed" == "true" ]] || [[ "$has_marker" != "true" ]]; then
              echo "build_${name}=true" >> $GITHUB_OUTPUT
              echo "  $name: BUILD (force=$FORCE ver=$ver_changed marker=$has_marker)"
            else
              echo "build_${name}=false" >> $GITHUB_OUTPUT
              echo "  $name: SKIP (unchanged + succeeded)"
            fi
          }

          echo "=== Build decisions ==="
          decide azahar      "${{ steps.versions.outputs.ver_azahar }}"   "${{ steps.marker-azahar.outputs.cache-hit }}"
          decide dolphin     "${{ steps.versions.outputs.ver_dolphin }}"  "${{ steps.marker-dolphin.outputs.cache-hit }}"
          decide duckstation "${{ steps.versions.outputs.ver_duck }}"     "${{ steps.marker-duck.outputs.cache-hit }}"
          decide esde        "${{ steps.versions.outputs.ver_esde }}"     "${{ steps.marker-esde.outputs.cache-hit }}"
          decide melonds     "${{ steps.versions.outputs.ver_melonds }}"  "${{ steps.marker-melonds.outputs.cache-hit }}"
          decide ppsspp      "${{ steps.versions.outputs.ver_ppsspp }}"   "${{ steps.marker-ppsspp.outputs.cache-hit }}"
          decide xemu        "${{ steps.versions.outputs.ver_xemu }}"     "${{ steps.marker-xemu.outputs.cache-hit }}"

          # Libretro and setperf: no version check, only hash-based
          decide_no_ver() {
            local name="$1"
            local has_marker="$2"

            if [[ "$FORCE" == "true" ]] || [[ "$has_marker" != "true" ]]; then
              echo "build_${name}=true" >> $GITHUB_OUTPUT
              echo "  $name: BUILD (force=$FORCE marker=$has_marker)"
            else
              echo "build_${name}=false" >> $GITHUB_OUTPUT
              echo "  $name: SKIP (unchanged + succeeded)"
            fi
          }

          # Libretro rebuilds if either heavy or light changed
          LIBRETRO_HEAVY_OK="${{ steps.marker-libretro-heavy.outputs.cache-hit }}"
          LIBRETRO_LIGHT_OK="${{ steps.marker-libretro-light.outputs.cache-hit }}"
          if [[ "$FORCE" == "true" ]] || [[ "$LIBRETRO_HEAVY_OK" != "true" ]] || [[ "$LIBRETRO_LIGHT_OK" != "true" ]]; then
            echo "build_libretro=true" >> $GITHUB_OUTPUT
            echo "  libretro: BUILD (force=$FORCE heavy_marker=$LIBRETRO_HEAVY_OK light_marker=$LIBRETRO_LIGHT_OK)"
          else
            echo "build_libretro=false" >> $GITHUB_OUTPUT
            echo "  libretro: SKIP"
          fi

          decide_no_ver setperf "${{ steps.marker-setperf.outputs.cache-hit }}"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Cache Docker image
        id: cache
        uses: actions/cache@v4
        with:
          path: /tmp/emu-deps.tar
          key: ${{ env.CACHE_KEY }}

      - name: Create base image if not cached
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          docker run --name emu-deps --platform linux/arm64 ubuntu:24.04 bash -c 'echo "base image"'
          docker commit emu-deps emu-deps-image
          docker save emu-deps-image -o /tmp/emu-deps.tar
          docker rm emu-deps

      - name: Load and update base image
        run: |
          docker load -i /tmp/emu-deps.tar
          docker run --name emu-deps-update --platform linux/arm64 \
            emu-deps-image bash -c '
              set -e
              export DEBIAN_FRONTEND=noninteractive

              apt-get update
              apt-get install -y \
                build-essential cmake ninja-build git pkg-config meson dpkg-dev \
                clang llvm lld libc++-dev libc++abi-dev \
                ccache patchelf \
                python3 python3-pip python3-yaml \
                libjemalloc-dev libwayland-dev \
                qt6-base-dev qt6-base-private-dev qt6-multimedia-dev qt6-tools-dev \
                libqt6opengl6-dev libqt6svg6-dev \
                qtbase5-dev qtbase5-private-dev qtmultimedia5-dev qttools5-dev \
                libsdl2-dev libsdl2-ttf-dev \
                libavcodec-dev libavformat-dev libavutil-dev libswscale-dev libavfilter-dev \
                libssl-dev libcurl4-openssl-dev \
                libfmt-dev libzstd-dev libpng-dev liblz4-dev libbz2-dev \
                libpugixml-dev nlohmann-json3-dev \
                libusb-1.0-0-dev libhidapi-dev libevdev-dev \
                libspeexdsp-dev glslang-tools spirv-tools \
                libboost-serialization-dev libboost-context-dev libcubeb-dev libenet-dev \
                libsfml-dev libminiupnpc-dev libmbedtls-dev \
                libsystemd-dev libbluetooth-dev libasound2-dev libpulse-dev \
                liblzo2-dev libxxhash-dev libspng-dev \
                extra-cmake-modules \
                libslirp-dev libarchive-dev \
                libglew-dev libsnappy-dev libzip-dev \
                libfreeimage-dev libfreetype-dev libvlc-dev libpoppler-cpp-dev \
                libepoxy-dev libpixman-1-dev libgtk-3-dev \
                libsamplerate0-dev libpcap-dev libglib2.0-dev \
                libfaad-dev libwebp-dev libsharpyuv-dev libwebpmux3 libwebpdemux2 \
                libpng-dev libjpeg-dev \
                libgit2-dev libharfbuzz-dev \
                gettext \
                libdbus-1-dev libfontconfig1-dev libudev-dev \
                libxcb1-dev libxcb-composite0-dev libxcb-cursor-dev libxcb-damage0-dev \
                libxcb-glx0-dev libxcb-icccm4-dev libxcb-image0-dev libxcb-keysyms1-dev \
                libxcb-present-dev libxcb-randr0-dev libxcb-render0-dev libxcb-render-util0-dev \
                libxcb-shape0-dev libxcb-shm0-dev libxcb-sync-dev libxcb-xfixes0-dev \
                libxcb-xinerama0-dev libxcb-xinput-dev libxcb-xkb-dev \
                libxcb-util-dev libxcb-util0-dev libxcb-ewmh-dev libxcb-dri2-0-dev libxcb-dri3-dev \
                libxkbcommon-dev libxkbcommon-x11-dev libx11-xcb-dev libx11-dev libxext-dev \
                libxrender-dev libxi-dev libxkbfile-dev libxrandr-dev libxcursor-dev \
                libdecor-0-dev libegl-dev libopengl-dev libdrm-dev \
                libpipewire-0.3-dev libinput-dev libgudev-1.0-dev \
                libva-dev libopus-dev \
                autoconf automake libtool curl wget xz-utils

              apt-get clean
              rm -rf /var/lib/apt/lists/*
            '
          docker commit emu-deps-update emu-deps-image
          docker save emu-deps-image -o /tmp/emu-deps.tar
          docker rm emu-deps-update

  # ===========================================================================
  # BUILD JOBS (with ccache and timeout handling)
  # ===========================================================================

  build-azahar:
    needs: prepare
    if: needs.prepare.outputs.build_azahar == 'true'
    runs-on: ubuntu-24.04
    outputs:
      completed: ${{ steps.build.outputs.completed }}
    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Restore cached image
        uses: actions/cache@v4
        with:
          path: /tmp/emu-deps.tar
          key: ${{ env.CACHE_KEY }}

      - name: Load image
        run: docker load -i /tmp/emu-deps.tar

      - name: Restore ccache
        uses: actions/cache/restore@v4
        with:
          path: /tmp/ccache-azahar
          key: ccache-azahar-${{ needs.prepare.outputs.azahar_version }}
          restore-keys: |
            ccache-azahar-

      - name: Build Azahar
        id: build
        run: |
          mkdir -p /tmp/ccache-azahar

          # Start timer
          START_TIME=$(date +%s)

          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/workspace \
            -v /tmp/ccache-azahar:/ccache \
            -e VERSION=${{ needs.prepare.outputs.azahar_version }} \
            -e CCACHE_DIR=/ccache \
            -e BUILD_TIMEOUT=${{ env.BUILD_TIMEOUT }} \
            -e START_TIME=$START_TIME \
            emu-deps-image bash -c '
              set -e

              # Setup ccache
              export PATH="/usr/lib/ccache:$PATH"
              export CCACHE_MAXSIZE=5G
              ccache -z

              # Clone source
              if [[ ! -d /workspace/src-azahar ]]; then
                git clone https://github.com/azahar-emu/azahar.git /workspace/src-azahar
              fi

              cd /workspace/src-azahar
              git fetch origin --tags
              git checkout "$VERSION"
              git submodule update --init --recursive

              # Fix X11 None macro conflict - undef the X11 macro before settings.h enums
              # X11 headers define "None" as 0L which breaks C++ enums using None as a value
              { echo "#ifdef None"; echo "#undef None"; echo "#endif"; cat src/common/settings.h; } > src/common/settings.h.tmp
              mv src/common/settings.h.tmp src/common/settings.h

              mkdir -p build && cd build

              # Configure if needed
              if [[ ! -f build.ninja ]]; then
                cmake .. -G Ninja \
                  -DCMAKE_BUILD_TYPE=Release \
                  -DCMAKE_INSTALL_PREFIX=/usr \
                  -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
                  -DCMAKE_C_COMPILER_LAUNCHER=ccache \
                  -DCMAKE_CXX_COMPILER=clang++ \
                  -DCMAKE_C_COMPILER=clang \
                  -DCMAKE_C_FLAGS="-O3 -flto=thin -march=armv8-a+crc+simd -mtune=cortex-a57" \
                  -DCMAKE_CXX_FLAGS="-O3 -flto=thin -march=armv8-a+crc+simd -mtune=cortex-a57" \
                  -DCMAKE_EXE_LINKER_FLAGS="-ljemalloc" \
                  -DCMAKE_SHARED_LINKER_FLAGS="-ljemalloc" \
                  -DENABLE_VULKAN=ON \
                  -DENABLE_OPENGL=ON \
                  -DENABLE_QT_GUI=ON \
                  -DENABLE_SDL2_FRONTEND=OFF \
                  -DENABLE_TESTS=OFF \
                  -DENABLE_WEB_SERVICE=OFF \
                  -DENABLE_X11=ON
              fi

              # Build with timeout check
              timeout ${BUILD_TIMEOUT}s ninja -j$(nproc) || {
                EXIT_CODE=$?
                ccache -s
                if [[ $EXIT_CODE -eq 124 ]]; then
                  echo "TIMEOUT - will retry with cache"
                  echo "timeout" > /workspace/build-status
                  exit 0
                fi
                exit $EXIT_CODE
              }

              # Package
              DESTDIR=/tmp/pkg ninja install
              VERSION_CLEAN=$(echo "$VERSION" | sed "s/^v//")
              mkdir -p /tmp/pkg/DEBIAN
              cat > /tmp/pkg/DEBIAN/control << EOF
          Package: azahar-emu-l4t
          Version: ${VERSION_CLEAN}
          Architecture: arm64
          Maintainer: Ethiquema <noreply@ethiquema.github.io>
          Depends: libc6, libjemalloc2, libqt6widgets6, libqt6gui6, libqt6core6, libqt6multimedia6, libqt6opengl6, libsdl2-2.0-0, libssl3t64, libavcodec60, libavformat60, libswscale7, libspeexdsp1, libfmt9, libzstd1, libusb-1.0-0, libhidapi-hidraw0, libboost-serialization1.83.0, libenet7, liblz4-1
          Provides: citra
          Replaces: citra
          Section: games
          Priority: optional
          Description: Azahar 3DS Emulator (ARM64 L4T build)
          EOF
              dpkg-deb --build /tmp/pkg /workspace/azahar-emu-l4t_${VERSION_CLEAN}_arm64.deb

              ccache -s
              echo "completed" > /workspace/build-status
            '

          # Check result
          if [[ -f build-status ]] && [[ "$(cat build-status)" == "completed" ]]; then
            echo "completed=true" >> $GITHUB_OUTPUT
          else
            echo "completed=false" >> $GITHUB_OUTPUT
          fi

      - name: Save ccache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: /tmp/ccache-azahar
          key: ccache-azahar-${{ needs.prepare.outputs.azahar_version }}-${{ github.run_id }}

      - name: Upload artifact
        if: steps.build.outputs.completed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deb-azahar
          path: "*.deb"
          retention-days: 1

      - name: Save success marker
        if: steps.build.outputs.completed == 'true'
        run: mkdir -p /tmp/marker && echo ok > /tmp/marker/ok

      - name: Upload success marker
        if: steps.build.outputs.completed == 'true'
        uses: actions/cache/save@v4
        with:
          path: /tmp/marker
          key: success-azahar-${{ needs.prepare.outputs.hash_azahar }}

      - name: Trigger retry if timeout
        if: steps.build.outputs.completed == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-emulators.yml',
              ref: 'main'
            });
            console.log('Triggered retry workflow');

  build-dolphin:
    needs: prepare
    if: needs.prepare.outputs.build_dolphin == 'true'
    runs-on: ubuntu-24.04
    outputs:
      completed: ${{ steps.build.outputs.completed }}
    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Restore cached image
        uses: actions/cache@v4
        with:
          path: /tmp/emu-deps.tar
          key: ${{ env.CACHE_KEY }}

      - name: Load image
        run: docker load -i /tmp/emu-deps.tar

      - name: Restore ccache
        uses: actions/cache/restore@v4
        with:
          path: /tmp/ccache-dolphin
          key: ccache-dolphin-${{ needs.prepare.outputs.dolphin_short }}
          restore-keys: |
            ccache-dolphin-

      - name: Build Dolphin
        id: build
        run: |
          mkdir -p /tmp/ccache-dolphin

          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/workspace \
            -v /tmp/ccache-dolphin:/ccache \
            -e COMMIT=${{ needs.prepare.outputs.dolphin_commit }} \
            -e SHORT=${{ needs.prepare.outputs.dolphin_short }} \
            -e CCACHE_DIR=/ccache \
            -e BUILD_TIMEOUT=${{ env.BUILD_TIMEOUT }} \
            emu-deps-image bash -c '
              set -e

              export PATH="/usr/lib/ccache:$PATH"
              export CCACHE_MAXSIZE=5G
              ccache -z

              if [[ ! -d /workspace/src-dolphin ]]; then
                git clone https://github.com/dolphin-emu/dolphin.git /workspace/src-dolphin
              fi

              cd /workspace/src-dolphin
              git fetch origin
              git checkout "$COMMIT"
              git submodule update --init --recursive
              mkdir -p build && cd build

              if [[ ! -f build.ninja ]]; then
                cmake .. -G Ninja \
                  -DCMAKE_BUILD_TYPE=Release \
                  -DCMAKE_INSTALL_PREFIX=/usr \
                  -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
                  -DCMAKE_C_COMPILER_LAUNCHER=ccache \
                  -DCMAKE_C_FLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57" \
                  -DCMAKE_CXX_FLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57" \
                  -DCMAKE_EXE_LINKER_FLAGS="-ljemalloc" \
                  -DCMAKE_SHARED_LINKER_FLAGS="-ljemalloc" \
                  -DENABLE_VULKAN=ON \
                  -DENABLE_X11=ON \
                  -DENABLE_WAYLAND=OFF \
                  -DENABLE_TESTS=OFF \
                  -DENABLE_ANALYTICS=OFF
              fi

              timeout ${BUILD_TIMEOUT}s ninja -j$(nproc) || {
                EXIT_CODE=$?
                ccache -s
                if [[ $EXIT_CODE -eq 124 ]]; then
                  echo "timeout" > /workspace/build-status
                  exit 0
                fi
                exit $EXIT_CODE
              }

              DESTDIR=/tmp/pkg ninja install
              PKG_VERSION="0.0.0+git.${SHORT}"
              mkdir -p /tmp/pkg/DEBIAN
              cat > /tmp/pkg/DEBIAN/control << EOF
          Package: dolphin-emu-l4t
          Version: ${PKG_VERSION}
          Architecture: arm64
          Maintainer: Ethiquema <noreply@ethiquema.github.io>
          Depends: libc6, libjemalloc2, libqt6widgets6, libqt6gui6, libqt6core6, libavcodec60, libavformat60, libswscale7, libevdev2, libminiupnpc17, libmbedtls21, libcurl4t64, libhidapi-hidraw0, libsystemd0, libbluetooth3, libasound2t64, libpulse0, libpugixml1v5, libbz2-1.0, libzstd1, liblzo2-2, libpng16-16t64, libusb-1.0-0, libfmt9, libsfml-system2.6, libsfml-network2.6, libxxhash0, libspng0
          Section: games
          Priority: optional
          Description: Dolphin GameCube/Wii Emulator (ARM64 L4T build)
          EOF
              dpkg-deb --build /tmp/pkg /workspace/dolphin-emu-l4t_${PKG_VERSION}_arm64.deb

              ccache -s
              echo "completed" > /workspace/build-status
            '

          if [[ -f build-status ]] && [[ "$(cat build-status)" == "completed" ]]; then
            echo "completed=true" >> $GITHUB_OUTPUT
          else
            echo "completed=false" >> $GITHUB_OUTPUT
          fi

      - name: Save ccache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: /tmp/ccache-dolphin
          key: ccache-dolphin-${{ needs.prepare.outputs.dolphin_short }}-${{ github.run_id }}

      - name: Upload artifact
        if: steps.build.outputs.completed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deb-dolphin
          path: "*.deb"
          retention-days: 1

      - name: Save success marker
        if: steps.build.outputs.completed == 'true'
        run: mkdir -p /tmp/marker && echo ok > /tmp/marker/ok

      - name: Upload success marker
        if: steps.build.outputs.completed == 'true'
        uses: actions/cache/save@v4
        with:
          path: /tmp/marker
          key: success-dolphin-${{ needs.prepare.outputs.hash_dolphin }}

      - name: Trigger retry if timeout
        if: steps.build.outputs.completed == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-emulators.yml',
              ref: 'main'
            });

  # DuckStation dependencies (Qt6, SDL3, etc.) - built separately for caching
  build-duckstation-deps:
    needs: prepare
    if: needs.prepare.outputs.build_duckstation == 'true'
    runs-on: ubuntu-24.04
    outputs:
      deps_ready: ${{ steps.check.outputs.deps_ready }}
    steps:
      - name: Check if deps already cached
        id: cache-check
        uses: actions/cache/restore@v4
        with:
          path: /tmp/duck-deps
          key: duck-deps-v2
          lookup-only: true

      - name: Set up QEMU
        if: steps.cache-check.outputs.cache-hit != 'true'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Restore cached image
        if: steps.cache-check.outputs.cache-hit != 'true'
        uses: actions/cache@v4
        with:
          path: /tmp/emu-deps.tar
          key: ${{ env.CACHE_KEY }}

      - name: Load image
        if: steps.cache-check.outputs.cache-hit != 'true'
        run: docker load -i /tmp/emu-deps.tar

      - name: Build DuckStation dependencies
        id: build-deps
        if: steps.cache-check.outputs.cache-hit != 'true'
        run: |
          mkdir -p /tmp/duck-deps

          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/workspace \
            -v /tmp/duck-deps:/deps \
            -e COMMIT=${{ needs.prepare.outputs.duck_commit }} \
            emu-deps-image bash -c '
              set -e

              # Clone source
              git clone --depth 1 https://github.com/stenzek/duckstation.git /workspace/src-duck
              cd /workspace/src-duck
              git fetch --depth 1 origin "$COMMIT"
              git checkout "$COMMIT"

              # Build dependencies with official script
              echo "Building dependencies with official script..."
              # Remove -system-harfbuzz to use bundled version
              sed -i "s/-system-harfbuzz//" scripts/deps/build-dependencies-linux.sh
              scripts/deps/build-dependencies-linux.sh /deps

              echo "Dependencies built successfully"
            '

      - name: Save deps cache
        if: steps.cache-check.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: /tmp/duck-deps
          key: duck-deps-v2

      - name: Check deps status
        id: check
        run: echo "deps_ready=true" >> $GITHUB_OUTPUT

      - name: Save success marker
        if: always() && steps.check.outputs.deps_ready == 'true'
        run: mkdir -p /tmp/marker && echo ok > /tmp/marker/ok

      - name: Upload success marker
        if: always() && steps.check.outputs.deps_ready == 'true'
        uses: actions/cache/save@v4
        with:
          path: /tmp/marker
          key: success-duck-deps-${{ needs.prepare.outputs.hash_duck_deps }}

  # DuckStation build (uses pre-built dependencies)
  build-duckstation:
    needs: [prepare, build-duckstation-deps]
    if: needs.prepare.outputs.build_duckstation == 'true'
    runs-on: ubuntu-24.04
    outputs:
      completed: ${{ steps.build.outputs.completed }}
    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Restore cached image
        uses: actions/cache@v4
        with:
          path: /tmp/emu-deps.tar
          key: ${{ env.CACHE_KEY }}

      - name: Load image
        run: docker load -i /tmp/emu-deps.tar

      - name: Restore ccache
        uses: actions/cache/restore@v4
        with:
          path: /tmp/ccache-duck
          key: ccache-duck-${{ needs.prepare.outputs.duck_short }}
          restore-keys: |
            ccache-duck-

      - name: Restore deps cache
        uses: actions/cache/restore@v4
        with:
          path: /tmp/duck-deps
          key: duck-deps-v2

      - name: Build DuckStation
        id: build
        run: |
          mkdir -p /tmp/ccache-duck

          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/workspace \
            -v /tmp/ccache-duck:/ccache \
            -v /tmp/duck-deps:/deps \
            -e COMMIT=${{ needs.prepare.outputs.duck_commit }} \
            -e SHORT=${{ needs.prepare.outputs.duck_short }} \
            -e CCACHE_DIR=/ccache \
            -e BUILD_TIMEOUT=${{ env.BUILD_TIMEOUT }} \
            emu-deps-image bash -c '
              set -e

              export PATH="/usr/lib/ccache:$PATH"
              export CCACHE_MAXSIZE=5G
              ccache -z

              # Clone or update source
              if [[ ! -d /workspace/src-duck ]]; then
                git clone --recursive https://github.com/stenzek/duckstation.git /workspace/src-duck
              fi

              cd /workspace/src-duck
              git fetch --unshallow 2>/dev/null || git fetch origin
              git checkout "$COMMIT"
              git submodule update --init --recursive

              mkdir -p build && cd build

              if [[ ! -f build.ninja ]]; then
                cmake .. -G Ninja \
                  -DCMAKE_BUILD_TYPE=Release \
                  -DCMAKE_INSTALL_PREFIX=/usr \
                  -DCMAKE_PREFIX_PATH=/deps \
                  -DCMAKE_C_COMPILER=clang \
                  -DCMAKE_CXX_COMPILER=clang++ \
                  -DCMAKE_EXE_LINKER_FLAGS_INIT="-fuse-ld=lld -ljemalloc" \
                  -DCMAKE_MODULE_LINKER_FLAGS_INIT="-fuse-ld=lld" \
                  -DCMAKE_SHARED_LINKER_FLAGS_INIT="-fuse-ld=lld -ljemalloc" \
                  -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
                  -DCMAKE_C_COMPILER_LAUNCHER=ccache \
                  -DCMAKE_C_FLAGS="-O3 -flto=thin -march=armv8-a+crc+simd -mtune=cortex-a57" \
                  -DCMAKE_CXX_FLAGS="-O3 -flto=thin -march=armv8-a+crc+simd -mtune=cortex-a57" \
                  -DCMAKE_INTERPROCEDURAL_OPTIMIZATION=ON \
                  -DENABLE_WAYLAND=OFF \
                  -DENABLE_X11=ON
              fi

              timeout ${BUILD_TIMEOUT}s ninja -j$(nproc) || {
                EXIT_CODE=$?
                ccache -s
                if [[ $EXIT_CODE -eq 124 ]]; then
                  echo "timeout" > /workspace/build-status
                  exit 0
                fi
                exit $EXIT_CODE
              }

              # DuckStation has no install target, copy manually
              mkdir -p /tmp/pkg/usr/bin /tmp/pkg/usr/lib/duckstation /tmp/pkg/usr/share/applications

              cp bin/duckstation-qt /tmp/pkg/usr/bin/
              cp -r bin/resources /tmp/pkg/usr/lib/duckstation/ 2>/dev/null || true

              # Bundle the custom-built libraries
              cp /deps/lib/*.so* /tmp/pkg/usr/lib/duckstation/ 2>/dev/null || true

              # Set rpath for bundled libs
              patchelf --set-rpath /usr/lib/duckstation /tmp/pkg/usr/bin/duckstation-qt 2>/dev/null || true

              cat > /tmp/pkg/usr/share/applications/duckstation.desktop << DESK
          [Desktop Entry]
          Name=DuckStation
          Comment=PlayStation 1 Emulator
          Exec=duckstation-qt
          Icon=duckstation
          Terminal=false
          Type=Application
          Categories=Game;Emulator;
          DESK

              PKG_VERSION="0.0.0+git.${SHORT}"
              mkdir -p /tmp/pkg/DEBIAN
              cat > /tmp/pkg/DEBIAN/control << EOF
          Package: duckstation-l4t
          Version: ${PKG_VERSION}
          Architecture: arm64
          Maintainer: Ethiquema <noreply@ethiquema.github.io>
          Depends: libc6, libjemalloc2, libdbus-1-3, libcurl4t64, libwayland-client0, libudev1
          Section: games
          Priority: optional
          Description: DuckStation PS1 Emulator (ARM64 L4T build)
           Includes bundled Qt6, SDL3 and other libraries.
          EOF
              dpkg-deb --build /tmp/pkg /workspace/duckstation-l4t_${PKG_VERSION}_arm64.deb

              ccache -s
              echo "completed" > /workspace/build-status
            '

          if [[ -f build-status ]] && [[ "$(cat build-status)" == "completed" ]]; then
            echo "completed=true" >> $GITHUB_OUTPUT
          else
            echo "completed=false" >> $GITHUB_OUTPUT
          fi

      - name: Save ccache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: /tmp/ccache-duck
          key: ccache-duck-${{ needs.prepare.outputs.duck_short }}-${{ github.run_id }}

      - name: Upload artifact
        if: steps.build.outputs.completed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deb-duckstation
          path: "*.deb"
          retention-days: 1

      - name: Save success marker
        if: steps.build.outputs.completed == 'true'
        run: mkdir -p /tmp/marker && echo ok > /tmp/marker/ok

      - name: Upload success marker
        if: steps.build.outputs.completed == 'true'
        uses: actions/cache/save@v4
        with:
          path: /tmp/marker
          key: success-duck-${{ needs.prepare.outputs.hash_duck }}

      - name: Trigger retry if timeout
        if: steps.build.outputs.completed == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-emulators.yml',
              ref: 'main'
            });

  build-esde:
    needs: prepare
    if: needs.prepare.outputs.build_esde == 'true'
    runs-on: ubuntu-24.04
    outputs:
      completed: ${{ steps.build.outputs.completed }}
    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Restore cached image
        uses: actions/cache@v4
        with:
          path: /tmp/emu-deps.tar
          key: ${{ env.CACHE_KEY }}

      - name: Load image
        run: docker load -i /tmp/emu-deps.tar

      - name: Restore ccache
        uses: actions/cache/restore@v4
        with:
          path: /tmp/ccache-esde
          key: ccache-esde-${{ needs.prepare.outputs.esde_version }}
          restore-keys: |
            ccache-esde-

      - name: Build EmulationStation-DE
        id: build
        run: |
          mkdir -p /tmp/ccache-esde

          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/workspace \
            -v /tmp/ccache-esde:/ccache \
            -e VERSION=${{ needs.prepare.outputs.esde_version }} \
            -e CCACHE_DIR=/ccache \
            -e BUILD_TIMEOUT=${{ env.BUILD_TIMEOUT }} \
            emu-deps-image bash -c '
              set -e

              export PATH="/usr/lib/ccache:$PATH"
              export CCACHE_MAXSIZE=5G
              ccache -z

              if [[ ! -d /workspace/src-esde ]]; then
                git clone https://gitlab.com/es-de/emulationstation-de.git /workspace/src-esde
              fi

              cd /workspace/src-esde
              git fetch origin --tags
              git checkout "$VERSION"
              mkdir -p build && cd build

              if [[ ! -f build.ninja ]]; then
                cmake .. -G Ninja \
                  -DCMAKE_BUILD_TYPE=Release \
                  -DCMAKE_INSTALL_PREFIX=/usr \
                  -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
                  -DCMAKE_C_COMPILER_LAUNCHER=ccache \
                  -DCMAKE_C_FLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57" \
                  -DCMAKE_CXX_FLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57"
              fi

              timeout ${BUILD_TIMEOUT}s ninja -j$(nproc) || {
                EXIT_CODE=$?
                ccache -s
                if [[ $EXIT_CODE -eq 124 ]]; then
                  echo "timeout" > /workspace/build-status
                  exit 0
                fi
                exit $EXIT_CODE
              }

              DESTDIR=/tmp/pkg ninja install
              VERSION_CLEAN=$(echo "$VERSION" | sed "s/^v//")
              mkdir -p /tmp/pkg/DEBIAN
              cat > /tmp/pkg/DEBIAN/control << EOF
          Package: emulationstation-de-l4t
          Version: ${VERSION_CLEAN}
          Architecture: arm64
          Maintainer: Ethiquema <noreply@ethiquema.github.io>
          Depends: libc6, libsdl2-2.0-0, libavcodec60, libavformat60, libswscale7, libfreeimage3t64, libfreetype6, libcurl4t64, libpugixml1v5, libvlc5, libpoppler-cpp0t64
          Provides: emulationstation
          Conflicts: emulationstation
          Section: games
          Priority: optional
          Description: EmulationStation Desktop Edition (ARM64 L4T build)
          EOF
              dpkg-deb --build /tmp/pkg /workspace/emulationstation-de-l4t_${VERSION_CLEAN}_arm64.deb

              ccache -s
              echo "completed" > /workspace/build-status
            '

          if [[ -f build-status ]] && [[ "$(cat build-status)" == "completed" ]]; then
            echo "completed=true" >> $GITHUB_OUTPUT
          else
            echo "completed=false" >> $GITHUB_OUTPUT
          fi

      - name: Save ccache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: /tmp/ccache-esde
          key: ccache-esde-${{ needs.prepare.outputs.esde_version }}-${{ github.run_id }}

      - name: Upload artifact
        if: steps.build.outputs.completed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deb-esde
          path: "*.deb"
          retention-days: 1

      - name: Save success marker
        if: steps.build.outputs.completed == 'true'
        run: mkdir -p /tmp/marker && echo ok > /tmp/marker/ok

      - name: Upload success marker
        if: steps.build.outputs.completed == 'true'
        uses: actions/cache/save@v4
        with:
          path: /tmp/marker
          key: success-esde-${{ needs.prepare.outputs.hash_esde }}

      - name: Trigger retry if timeout
        if: steps.build.outputs.completed == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-emulators.yml',
              ref: 'main'
            });

  build-melonds:
    needs: prepare
    if: needs.prepare.outputs.build_melonds == 'true'
    runs-on: ubuntu-24.04
    outputs:
      completed: ${{ steps.build.outputs.completed }}
    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Restore cached image
        uses: actions/cache@v4
        with:
          path: /tmp/emu-deps.tar
          key: ${{ env.CACHE_KEY }}

      - name: Load image
        run: docker load -i /tmp/emu-deps.tar

      - name: Restore ccache
        uses: actions/cache/restore@v4
        with:
          path: /tmp/ccache-melonds
          key: ccache-melonds-${{ needs.prepare.outputs.melonds_version }}
          restore-keys: |
            ccache-melonds-

      - name: Build melonDS
        id: build
        run: |
          mkdir -p /tmp/ccache-melonds

          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/workspace \
            -v /tmp/ccache-melonds:/ccache \
            -e VERSION=${{ needs.prepare.outputs.melonds_version }} \
            -e CCACHE_DIR=/ccache \
            -e BUILD_TIMEOUT=${{ env.BUILD_TIMEOUT }} \
            emu-deps-image bash -c '
              set -e

              export PATH="/usr/lib/ccache:$PATH"
              export CCACHE_MAXSIZE=5G
              ccache -z

              if [[ ! -d /workspace/src-melonds ]]; then
                git clone https://github.com/melonDS-emu/melonDS.git /workspace/src-melonds
              fi

              cd /workspace/src-melonds
              git fetch origin --tags
              git checkout "$VERSION"
              mkdir -p build && cd build

              if [[ ! -f build.ninja ]]; then
                cmake .. -G Ninja \
                  -DCMAKE_BUILD_TYPE=Release \
                  -DCMAKE_INSTALL_PREFIX=/usr \
                  -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
                  -DCMAKE_C_COMPILER_LAUNCHER=ccache \
                  -DCMAKE_C_FLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57" \
                  -DCMAKE_CXX_FLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57" \
                  -DCMAKE_EXE_LINKER_FLAGS="-ljemalloc" \
                  -DCMAKE_SHARED_LINKER_FLAGS="-ljemalloc"
              fi

              timeout ${BUILD_TIMEOUT}s ninja -j$(nproc) || {
                EXIT_CODE=$?
                ccache -s
                if [[ $EXIT_CODE -eq 124 ]]; then
                  echo "timeout" > /workspace/build-status
                  exit 0
                fi
                exit $EXIT_CODE
              }

              DESTDIR=/tmp/pkg ninja install
              VERSION_CLEAN=$(echo "$VERSION" | sed "s/^v//")
              mkdir -p /tmp/pkg/DEBIAN
              cat > /tmp/pkg/DEBIAN/control << EOF
          Package: melonds-l4t
          Version: ${VERSION_CLEAN}
          Architecture: arm64
          Maintainer: Ethiquema <noreply@ethiquema.github.io>
          Depends: libc6, libjemalloc2, libqt6widgets6, libqt6gui6, libqt6core6, libqt6multimedia6, libsdl2-2.0-0, libslirp0, libarchive13t64, libzstd1
          Section: games
          Priority: optional
          Description: melonDS Nintendo DS Emulator (ARM64 L4T build)
          EOF
              dpkg-deb --build /tmp/pkg /workspace/melonds-l4t_${VERSION_CLEAN}_arm64.deb

              ccache -s
              echo "completed" > /workspace/build-status
            '

          if [[ -f build-status ]] && [[ "$(cat build-status)" == "completed" ]]; then
            echo "completed=true" >> $GITHUB_OUTPUT
          else
            echo "completed=false" >> $GITHUB_OUTPUT
          fi

      - name: Save ccache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: /tmp/ccache-melonds
          key: ccache-melonds-${{ needs.prepare.outputs.melonds_version }}-${{ github.run_id }}

      - name: Upload artifact
        if: steps.build.outputs.completed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deb-melonds
          path: "*.deb"
          retention-days: 1

      - name: Save success marker
        if: steps.build.outputs.completed == 'true'
        run: mkdir -p /tmp/marker && echo ok > /tmp/marker/ok

      - name: Upload success marker
        if: steps.build.outputs.completed == 'true'
        uses: actions/cache/save@v4
        with:
          path: /tmp/marker
          key: success-melonds-${{ needs.prepare.outputs.hash_melonds }}

      - name: Trigger retry if timeout
        if: steps.build.outputs.completed == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-emulators.yml',
              ref: 'main'
            });

  build-ppsspp:
    needs: prepare
    if: needs.prepare.outputs.build_ppsspp == 'true'
    runs-on: ubuntu-24.04
    outputs:
      completed: ${{ steps.build.outputs.completed }}
    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Restore cached image
        uses: actions/cache@v4
        with:
          path: /tmp/emu-deps.tar
          key: ${{ env.CACHE_KEY }}

      - name: Load image
        run: docker load -i /tmp/emu-deps.tar

      - name: Restore ccache
        uses: actions/cache/restore@v4
        with:
          path: /tmp/ccache-ppsspp
          key: ccache-ppsspp-${{ needs.prepare.outputs.ppsspp_version }}
          restore-keys: |
            ccache-ppsspp-

      - name: Build PPSSPP
        id: build
        run: |
          mkdir -p /tmp/ccache-ppsspp

          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/workspace \
            -v /tmp/ccache-ppsspp:/ccache \
            -e VERSION=${{ needs.prepare.outputs.ppsspp_version }} \
            -e CCACHE_DIR=/ccache \
            -e BUILD_TIMEOUT=${{ env.BUILD_TIMEOUT }} \
            emu-deps-image bash -c '
              set -e

              export PATH="/usr/lib/ccache:$PATH"
              export CCACHE_MAXSIZE=5G
              ccache -z

              if [[ ! -d /workspace/src-ppsspp ]]; then
                git clone https://github.com/hrydgard/ppsspp.git /workspace/src-ppsspp
              fi

              cd /workspace/src-ppsspp
              git fetch origin --tags
              git checkout "$VERSION"
              git submodule update --init --recursive
              mkdir -p build && cd build

              if [[ ! -f build.ninja ]]; then
                cmake .. -G Ninja \
                  -DCMAKE_BUILD_TYPE=Release \
                  -DCMAKE_INSTALL_PREFIX=/usr \
                  -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
                  -DCMAKE_C_COMPILER_LAUNCHER=ccache \
                  -DCMAKE_C_FLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57" \
                  -DCMAKE_CXX_FLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57" \
                  -DCMAKE_EXE_LINKER_FLAGS="-ljemalloc" \
                  -DCMAKE_SHARED_LINKER_FLAGS="-ljemalloc" \
                  -DUSING_QT_UI=OFF \
                  -DHEADLESS=OFF \
                  -DUSE_WAYLAND_WSI=OFF \
                  -DVULKAN=ON
              fi

              timeout ${BUILD_TIMEOUT}s ninja -j$(nproc) || {
                EXIT_CODE=$?
                ccache -s
                if [[ $EXIT_CODE -eq 124 ]]; then
                  echo "timeout" > /workspace/build-status
                  exit 0
                fi
                exit $EXIT_CODE
              }

              mkdir -p /tmp/pkg/usr/bin /tmp/pkg/usr/share/applications /tmp/pkg/usr/share/ppsspp
              cp PPSSPPSDL /tmp/pkg/usr/bin/ppsspp
              cp -r ../assets /tmp/pkg/usr/share/ppsspp/

              cat > /tmp/pkg/usr/share/applications/ppsspp.desktop << DESK
          [Desktop Entry]
          Name=PPSSPP
          Comment=PlayStation Portable Emulator
          Exec=ppsspp
          Icon=ppsspp
          Terminal=false
          Type=Application
          Categories=Game;Emulator;
          DESK

              VERSION_CLEAN=$(echo "$VERSION" | sed "s/^v//")
              mkdir -p /tmp/pkg/DEBIAN
              cat > /tmp/pkg/DEBIAN/control << EOF
          Package: ppsspp-l4t
          Version: ${VERSION_CLEAN}
          Architecture: arm64
          Maintainer: Ethiquema <noreply@ethiquema.github.io>
          Depends: libc6, libjemalloc2, libsdl2-2.0-0, libsdl2-ttf-2.0-0, libglew2.2, libsnappy1v5, libavcodec60, libavformat60, libswscale7, libzip4t64, libpng16-16t64
          Provides: ppsspp
          Conflicts: ppsspp
          Section: games
          Priority: optional
          Description: PPSSPP PlayStation Portable Emulator (ARM64 L4T build)
          EOF
              dpkg-deb --build /tmp/pkg /workspace/ppsspp-l4t_${VERSION_CLEAN}_arm64.deb

              ccache -s
              echo "completed" > /workspace/build-status
            '

          if [[ -f build-status ]] && [[ "$(cat build-status)" == "completed" ]]; then
            echo "completed=true" >> $GITHUB_OUTPUT
          else
            echo "completed=false" >> $GITHUB_OUTPUT
          fi

      - name: Save ccache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: /tmp/ccache-ppsspp
          key: ccache-ppsspp-${{ needs.prepare.outputs.ppsspp_version }}-${{ github.run_id }}

      - name: Upload artifact
        if: steps.build.outputs.completed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deb-ppsspp
          path: "*.deb"
          retention-days: 1

      - name: Save success marker
        if: steps.build.outputs.completed == 'true'
        run: mkdir -p /tmp/marker && echo ok > /tmp/marker/ok

      - name: Upload success marker
        if: steps.build.outputs.completed == 'true'
        uses: actions/cache/save@v4
        with:
          path: /tmp/marker
          key: success-ppsspp-${{ needs.prepare.outputs.hash_ppsspp }}

      - name: Trigger retry if timeout
        if: steps.build.outputs.completed == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-emulators.yml',
              ref: 'main'
            });

  build-xemu:
    needs: prepare
    if: needs.prepare.outputs.build_xemu == 'true'
    runs-on: ubuntu-24.04
    outputs:
      completed: ${{ steps.build.outputs.completed }}
    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Restore cached image
        uses: actions/cache@v4
        with:
          path: /tmp/emu-deps.tar
          key: ${{ env.CACHE_KEY }}

      - name: Load image
        run: docker load -i /tmp/emu-deps.tar

      - name: Restore ccache
        uses: actions/cache/restore@v4
        with:
          path: /tmp/ccache-xemu
          key: ccache-xemu-${{ needs.prepare.outputs.xemu_version }}
          restore-keys: |
            ccache-xemu-

      - name: Build xemu
        id: build
        run: |
          mkdir -p /tmp/ccache-xemu

          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/workspace \
            -v /tmp/ccache-xemu:/ccache \
            -e VERSION=${{ needs.prepare.outputs.xemu_version }} \
            -e CCACHE_DIR=/ccache \
            -e BUILD_TIMEOUT=${{ env.BUILD_TIMEOUT }} \
            emu-deps-image bash -c '
              set -e

              export PATH="/usr/lib/ccache:$PATH"
              export CCACHE_MAXSIZE=5G
              ccache -z

              if [[ ! -d /workspace/src-xemu ]]; then
                git clone https://github.com/xemu-project/xemu.git /workspace/src-xemu
              fi

              cd /workspace/src-xemu
              git fetch origin --tags
              git checkout "$VERSION"
              git submodule update --init --recursive

              export CFLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57"
              export CXXFLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57"
              export LDFLAGS="-ljemalloc"

              # Build with X11 (XWayland)
              timeout ${BUILD_TIMEOUT}s ./build.sh --enable-sdl --disable-werror || {
                EXIT_CODE=$?
                ccache -s
                if [[ $EXIT_CODE -eq 124 ]]; then
                  echo "timeout" > /workspace/build-status
                  exit 0
                fi
                exit $EXIT_CODE
              }

              mkdir -p /tmp/pkg/usr/bin /tmp/pkg/usr/share/applications
              cp dist/xemu /tmp/pkg/usr/bin/

              cat > /tmp/pkg/usr/share/applications/xemu.desktop << DESK
          [Desktop Entry]
          Name=xemu
          Comment=Original Xbox Emulator
          Exec=xemu
          Icon=xemu
          Terminal=false
          Type=Application
          Categories=Game;Emulator;
          DESK

              VERSION_CLEAN=$(echo "$VERSION" | sed "s/^v//")
              mkdir -p /tmp/pkg/DEBIAN
              cat > /tmp/pkg/DEBIAN/control << EOF
          Package: xemu-l4t
          Version: ${VERSION_CLEAN}
          Architecture: arm64
          Maintainer: Ethiquema <noreply@ethiquema.github.io>
          Depends: libc6, libjemalloc2, libsdl2-2.0-0, libepoxy0, libpixman-1-0, libgtk-3-0t64, libssl3t64, libsamplerate0, libpcap0.8t64, libslirp0
          Section: games
          Priority: optional
          Description: xemu Original Xbox Emulator (ARM64 L4T build)
          EOF
              dpkg-deb --build /tmp/pkg /workspace/xemu-l4t_${VERSION_CLEAN}_arm64.deb

              ccache -s
              echo "completed" > /workspace/build-status
            '

          if [[ -f build-status ]] && [[ "$(cat build-status)" == "completed" ]]; then
            echo "completed=true" >> $GITHUB_OUTPUT
          else
            echo "completed=false" >> $GITHUB_OUTPUT
          fi

      - name: Save ccache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: /tmp/ccache-xemu
          key: ccache-xemu-${{ needs.prepare.outputs.xemu_version }}-${{ github.run_id }}

      - name: Upload artifact
        if: steps.build.outputs.completed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deb-xemu
          path: "*.deb"
          retention-days: 1

      - name: Save success marker
        if: steps.build.outputs.completed == 'true'
        run: mkdir -p /tmp/marker && echo ok > /tmp/marker/ok

      - name: Upload success marker
        if: steps.build.outputs.completed == 'true'
        uses: actions/cache/save@v4
        with:
          path: /tmp/marker
          key: success-xemu-${{ needs.prepare.outputs.hash_xemu }}

      - name: Trigger retry if timeout
        if: steps.build.outputs.completed == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-emulators.yml',
              ref: 'main'
            });

  # Libretro cores - Job 1: Heavy cores (FBNeo, MAME, VICE, DOSBox)
  build-libretro-heavy:
    needs: prepare
    if: needs.prepare.outputs.build_libretro == 'true'
    runs-on: ubuntu-24.04
    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Restore cached image
        uses: actions/cache@v4
        with:
          path: /tmp/emu-deps.tar
          key: ${{ env.CACHE_KEY }}

      - name: Load image
        run: docker load -i /tmp/emu-deps.tar

      - name: Restore ccache
        uses: actions/cache/restore@v4
        with:
          path: /tmp/ccache-libretro-heavy
          key: ccache-libretro-heavy-v1
          restore-keys: |
            ccache-libretro-heavy-

      - name: Build heavy Libretro cores
        id: build
        run: |
          mkdir -p /tmp/ccache-libretro-heavy

          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/workspace \
            -v /tmp/ccache-libretro-heavy:/ccache \
            -e CCACHE_DIR=/ccache \
            -e BUILD_TIMEOUT=${{ env.BUILD_TIMEOUT }} \
            emu-deps-image bash -c '
              set -e

              export PATH="/usr/lib/ccache:$PATH"
              export CCACHE_MAXSIZE=5G
              ccache -z

              # ARM64 build flags for Tegra X1 with LTO
              export CFLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57"
              export CXXFLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57"
              export LDFLAGS="-flto -ljemalloc"

              CORES_DIR=/workspace/libretro-cores
              PKG_DIR=/workspace/cores-heavy
              mkdir -p "$CORES_DIR" "$PKG_DIR"

              cd "$CORES_DIR"

              build_core() {
                local repo=$1
                local name=$2
                local subdir=${3:-}
                local make_args=${4:-}

                echo "=== Building $name ==="
                if [[ ! -d "$name" ]]; then
                  git clone --depth 1 --recursive "https://github.com/libretro/$repo.git" "$name"
                fi
                cd "$name"
                if [[ -n "$subdir" ]]; then
                  cd "$subdir"
                fi
                make clean 2>/dev/null || true
                timeout ${BUILD_TIMEOUT}s make -j$(nproc) platform=unix $make_args \
                  CC="ccache gcc" CXX="ccache g++" \
                  CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" \
                  SKIPDEPEND=1 WERROR=0 || {
                  EXIT_CODE=$?
                  if [[ $EXIT_CODE -eq 124 ]]; then
                    echo "TIMEOUT on $name"
                    exit 124
                  fi
                  exit $EXIT_CODE
                }
                find . -name "*.so" -exec cp {} "$PKG_DIR/" \;
                cd "$CORES_DIR"
              }

              # Heavy cores
              # FBNeo disabled: has Windows-specific types (RECT) not available on Linux ARM64
              # build_core FBNeo fbneo "src/burner/libretro"
              build_core mame2003-plus-libretro mame2003-plus
              build_core vice-libretro vice "" "EMUTYPE=x64"
              build_core dosbox-pure dosbox-pure

              ccache -s
              echo "completed" > /workspace/build-status-heavy
            '

          if [[ -f build-status-heavy ]] && [[ "$(cat build-status-heavy)" == "completed" ]]; then
            echo "completed=true" >> $GITHUB_OUTPUT
          else
            echo "completed=false" >> $GITHUB_OUTPUT
          fi

      - name: Save ccache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: /tmp/ccache-libretro-heavy
          key: ccache-libretro-heavy-v1-${{ github.run_id }}

      - name: Upload cores
        if: steps.build.outputs.completed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: libretro-cores-heavy
          path: "cores-heavy/*.so"
          retention-days: 1

      - name: Save success marker
        if: steps.build.outputs.completed == 'true'
        run: mkdir -p /tmp/marker && echo ok > /tmp/marker/ok

      - name: Upload success marker
        if: steps.build.outputs.completed == 'true'
        uses: actions/cache/save@v4
        with:
          path: /tmp/marker
          key: success-libretro-heavy-${{ needs.prepare.outputs.hash_libretro_heavy }}

      - name: Trigger retry if timeout
        if: steps.build.outputs.completed == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-emulators.yml',
              ref: 'main'
            });

  # Libretro cores - Job 2: Light cores (computers, misc consoles)
  build-libretro-light:
    needs: prepare
    if: needs.prepare.outputs.build_libretro == 'true'
    runs-on: ubuntu-24.04
    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Restore cached image
        uses: actions/cache@v4
        with:
          path: /tmp/emu-deps.tar
          key: ${{ env.CACHE_KEY }}

      - name: Load image
        run: docker load -i /tmp/emu-deps.tar

      - name: Restore ccache
        uses: actions/cache/restore@v4
        with:
          path: /tmp/ccache-libretro-light
          key: ccache-libretro-light-v1
          restore-keys: |
            ccache-libretro-light-

      - name: Build light Libretro cores
        id: build
        run: |
          mkdir -p /tmp/ccache-libretro-light

          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/workspace \
            -v /tmp/ccache-libretro-light:/ccache \
            -e CCACHE_DIR=/ccache \
            emu-deps-image bash -c '
              set -e

              export PATH="/usr/lib/ccache:$PATH"
              export CCACHE_MAXSIZE=5G
              ccache -z

              # ARM64 build flags for Tegra X1 with LTO
              # -Wno-error prevents warnings from failing the build
              export CFLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57 -Wno-error"
              export CXXFLAGS="-O3 -flto -march=armv8-a+crc+simd -mtune=cortex-a57 -Wno-error"
              export LDFLAGS="-flto -ljemalloc"

              CORES_DIR=/workspace/libretro-cores
              PKG_DIR=/workspace/cores-light
              mkdir -p "$CORES_DIR" "$PKG_DIR"

              cd "$CORES_DIR"

              build_core() {
                local repo=$1
                local name=$2
                local subdir=${3:-}
                local make_args=${4:-}

                echo "=== Building $name ==="
                if [[ ! -d "$name" ]]; then
                  git clone --depth 1 --recursive "https://github.com/libretro/$repo.git" "$name"
                fi
                cd "$name"
                if [[ -n "$subdir" ]]; then
                  cd "$subdir"
                fi
                make clean 2>/dev/null || true
                if make -j$(nproc) platform=unix $make_args \
                  CC="ccache gcc" CXX="ccache g++" \
                  CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS"; then
                  find . -name "*.so" -exec cp {} "$PKG_DIR/" \;
                else
                  echo "WARNING: Failed to build $name, skipping..."
                fi
                cd "$CORES_DIR"
              }

              # Computers (fmsx has broken source code, use bluemsx instead)
              # build_core fmsx-libretro fmsx
              build_core blueMSX-libretro bluemsx
              build_core PUAE puae
              build_core fuse-libretro fuse
              build_core libretro-cap32 cap32
              build_core libretro-atari800 atari800
              build_core px68k-libretro px68k
              build_core quasi88-libretro quasi88

              # Consoles
              build_core opera-libretro opera
              build_core neocd_libretro neocd
              build_core virtualjaguar-libretro virtualjaguar
              build_core libretro-o2em o2em
              build_core libretro-vecx vecx
              build_core FreeChaF freechaf
              build_core FreeIntv freeintv
              build_core geolith-libretro geolith

              # Games
              build_core libretro-prboom prboom
              build_core nxengine-libretro nxengine

              ccache -s
              echo "completed" > /workspace/build-status-light
            '

          if [[ -f build-status-light ]] && [[ "$(cat build-status-light)" == "completed" ]]; then
            echo "completed=true" >> $GITHUB_OUTPUT
          else
            echo "completed=false" >> $GITHUB_OUTPUT
          fi

      - name: Save ccache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: /tmp/ccache-libretro-light
          key: ccache-libretro-light-v1-${{ github.run_id }}

      - name: Upload cores
        if: steps.build.outputs.completed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: libretro-cores-light
          path: "cores-light/*.so"
          retention-days: 1

      - name: Save success marker
        if: steps.build.outputs.completed == 'true'
        run: mkdir -p /tmp/marker && echo ok > /tmp/marker/ok

      - name: Upload success marker
        if: steps.build.outputs.completed == 'true'
        uses: actions/cache/save@v4
        with:
          path: /tmp/marker
          key: success-libretro-light-${{ needs.prepare.outputs.hash_libretro_light }}

  # Package all libretro cores into single deb
  build-libretro-package:
    needs: [build-libretro-heavy, build-libretro-light]
    if: always() && (needs.build-libretro-heavy.result == 'success' || needs.build-libretro-light.result == 'success')
    runs-on: ubuntu-24.04
    steps:
      - name: Download heavy cores
        uses: actions/download-artifact@v4
        with:
          name: libretro-cores-heavy
          path: cores/
        continue-on-error: true

      - name: Download light cores
        uses: actions/download-artifact@v4
        with:
          name: libretro-cores-light
          path: cores/
        continue-on-error: true

      - name: Create package
        id: package
        run: |
          if ls cores/*.so 1>/dev/null 2>&1; then
            mkdir -p pkg/usr/lib/libretro pkg/DEBIAN
            cp cores/*.so pkg/usr/lib/libretro/

            cat > pkg/DEBIAN/control << 'EOF'
          Package: libretro-cores-l4t
          Version: 1.0.0
          Architecture: arm64
          Maintainer: Ethiquema <noreply@ethiquema.github.io>
          Depends: libc6, zlib1g, libjemalloc2
          Section: games
          Priority: optional
          Description: Additional Libretro cores (ARM64 L4T build)
           FBNeo, VICE, DOSBox Pure, fMSX, blueMSX, PUAE, Fuse, Cap32,
           Atari800, PX68k, Quasi88, Opera, NeoCD, Virtual Jaguar, O2EM,
           VecX, FreeChaF, FreeIntv, Geolith, PrBoom, NXEngine, MAME 2003+
          EOF

            dpkg-deb --build pkg libretro-cores-l4t_1.0.0_arm64.deb
            echo "has_deb=true" >> $GITHUB_OUTPUT
          else
            echo "No cores found"
            echo "has_deb=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload artifact
        if: steps.package.outputs.has_deb == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deb-libretro-cores
          path: "*.deb"
          retention-days: 1

  build-setperf:
    needs: prepare
    if: needs.prepare.outputs.build_setperf == 'true'
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Build setperf package
        run: |
          cd packages/setperf
          chmod +x build.sh
          ./build.sh

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: deb-setperf
          path: "packages/setperf/*.deb"
          retention-days: 1

      - name: Save success marker
        run: mkdir -p /tmp/marker && echo ok > /tmp/marker/ok

      - name: Upload success marker
        uses: actions/cache/save@v4
        with:
          path: /tmp/marker
          key: success-setperf-${{ needs.prepare.outputs.hash_setperf }}

  # ===========================================================================
  # UPDATE REPO: Collect all debs and update APT repository
  # ===========================================================================
  update-repo:
    needs: [prepare, build-azahar, build-dolphin, build-duckstation, build-esde, build-melonds, build-ppsspp, build-xemu, build-libretro-package, build-setperf]
    if: always()
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: deb-*
          merge-multiple: true

      - name: Check for packages
        id: check
        run: |
          if ls *.deb 1> /dev/null 2>&1; then
            echo "has_debs=true" >> $GITHUB_OUTPUT
            ls -la *.deb
          else
            echo "has_debs=false" >> $GITHUB_OUTPUT
            echo "No packages to publish"
          fi

      - name: Checkout gh-pages
        if: steps.check.outputs.has_debs == 'true'
        run: |
          git fetch origin gh-pages:gh-pages || true
          git worktree add gh-pages-dir gh-pages || {
            git worktree add --detach gh-pages-dir
            cd gh-pages-dir
            git checkout --orphan gh-pages
            git rm -rf . 2>/dev/null || true
            mkdir -p pool/main dists/noble/main/binary-arm64
            cd ..
          }

      - name: Install APT tools
        if: steps.check.outputs.has_debs == 'true'
        run: sudo apt-get update && sudo apt-get install -y dpkg-dev apt-utils

      - name: Import GPG key
        if: steps.check.outputs.has_debs == 'true'
        run: |
          echo "${{ secrets.PRIVATE }}" | gpg --batch --import
          gpg --armor --export "Ethiquema L4T Repo" > gh-pages-dir/public.key

      - name: Add packages to pool
        if: steps.check.outputs.has_debs == 'true'
        run: |
          mkdir -p gh-pages-dir/pool/main
          cp *.deb gh-pages-dir/pool/main/

      - name: Regenerate APT repository metadata
        if: steps.check.outputs.has_debs == 'true'
        run: |
          cd gh-pages-dir
          mkdir -p dists/noble/main/binary-arm64

          dpkg-scanpackages --arch arm64 pool/ > dists/noble/main/binary-arm64/Packages
          gzip -k -f dists/noble/main/binary-arm64/Packages

          cd dists/noble
          cat > Release << EOF
          Origin: Ethiquema L4T Repository
          Label: l4t-debs
          Suite: noble
          Codename: noble
          Architectures: arm64
          Components: main
          Description: L4T packages for Nintendo Switch
          EOF

          apt-ftparchive release . >> Release
          rm -f Release.gpg InRelease
          gpg --batch --default-key "Ethiquema L4T Repo" -abs -o Release.gpg Release
          gpg --batch --default-key "Ethiquema L4T Repo" --clearsign -o InRelease Release

      - name: Deploy to gh-pages
        if: steps.check.outputs.has_debs == 'true'
        run: |
          cd gh-pages-dir
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "Update APT repository" || echo "No changes"
          git push origin gh-pages

      - name: Save version trackers
        if: steps.check.outputs.has_debs == 'true'
        run: |
          echo "${{ needs.prepare.outputs.azahar_version }}" > .azahar-version
          echo "${{ needs.prepare.outputs.dolphin_commit }}" > .dolphin-commit
          echo "${{ needs.prepare.outputs.duck_commit }}" > .duckstation-commit
          echo "${{ needs.prepare.outputs.esde_version }}" > .esde-version
          echo "${{ needs.prepare.outputs.melonds_version }}" > .melonds-version
          echo "${{ needs.prepare.outputs.ppsspp_version }}" > .ppsspp-version
          echo "${{ needs.prepare.outputs.xemu_version }}" > .xemu-version

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .*-version .*-commit 2>/dev/null || true
          git commit -m "Update version trackers" || echo "No changes"
          git push origin main
